#include "imports/stdlib.fc";

;; this must be aligned with the minter's save_data contents (and deployJettonMinter's createFromConfig)
cell build_minter_init_data(int total_supply, slice admin_address, cell metadata, cell jetton_wallet_code) inline {
    return begin_cell()
        .store_coins(total_supply)
        .store_slice(admin_address)
        .store_ref(metadata)
        .store_ref(jetton_wallet_code)
    .end_cell();
}

;; taken from https://docs.ton.org/develop/func/cookbook#how-to-build-a-stateinit-cell, tested on counter factory
cell build_contract_init_state(cell init_code, cell init_data) inline {
    return begin_cell()
        .store_uint(0, 1) ;; split_depth:(Maybe (## 5))
        .store_uint(0, 1) ;; special:(Maybe TickTock)
        .store_uint(1, 1) ;; (Maybe ^Cell)
        .store_uint(1, 1) ;; (Maybe ^Cell)
        .store_uint(0, 1) ;; (HashmapE 256 SimpleLib)
        .store_ref(init_code)
        .store_ref(init_data)
    .end_cell();
}

;; layout is defined by: https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L105
;; implementation is based on https://docs.ton.org/develop/func/cookbook#generate-internal-address
;; and https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-utils.fc, tested on counter factory
;; not sure if anycast is needed and if other workchain ids will be needed in the future
slice calculate_minter_address(cell init_state) inline {
    return begin_cell()
        .store_uint(2, 2)          ;; addr_std$10
        .store_uint(0, 1)          ;; anycast nothing
        .store_int(0, 8)           ;; workchain id = 0 (might need adjustments in the future)
        .store_uint(cell_hash(init_state), 256)
    .end_cell()
    .begin_parse();
}

() deploy_jetton(cell init_state) impure inline {
    send_raw_message(
        begin_cell()
            ;; info = header
            .store_uint(0x18, 6)
            .store_slice(calculate_minter_address(init_state))
            .store_coins(0) ;; in nano; is needed > 0?
            .store_uint(0, 1 + 4 + 4 + 64 + 32)

            ;; init (Maybe (Either StateInit ^StateInit))
            .store_uint(1, 1)      ;; init is non-empty
            .store_uint(1, 1)      ;; serialized in another cell
            .store_ref(init_state) ;; ^StateInit

            ;; body
            .store_uint(0, 1) ;; in-place body (if adding by ref, switch to 1)
            ;; if non-empty body is needed: either
            ;; .store_ref(body)  and change â†‘ flag or
            ;; ..how to add an inline body? .store_slice(begin_parse(body)) ?
        .end_cell(),

        ;; mode 0? mode 64 = carry the remaining value in the new message
        ;; flag 16 = __
        0 + 16
    );
}

;; == storage ==
;; this must be aligned with jettonFactoryConfigToCell
(
    cell, ;; minter_code
    cell  ;; wallet_code
) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_ref(), ;; minter_code
        ds~load_ref()  ;; wallet_code
    );
}

;; == messages ==
const operation_deploy_new_jetton = 1;

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; accept empty messages (including sending TON to contract balance)
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    int operation_type = in_msg_body~load_uint(32);
    (cell minter_code, cell wallet_code) = load_data();

    ;; deploy new counter
    if (operation_type == operation_deploy_new_jetton) {
    }
}
